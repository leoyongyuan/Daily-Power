# 异步专题

异步是在Javascript继原型链后的又一大难点，而且经常在实际开发中经常遇到异步操作，所以大家应该不陌生，在面试中也往往会配合事件循环机制等知识点结合出组合拳暴打求职者。

所以这个知识点是非常关键且重要的，本文好好捋一下异步的整个知识脉络，包括Promise和事件循环机制等内容。

好了，话不多说直接进入正题。

## 什么是异步？

和异步有个相对的概念叫做同步。

所谓同步，就是按照你的代码顺序进行执行，而异步不按照代码顺序执行，因此执行效率更高。

异步任务会在浏览器单独中开出一个线程来处理，等同步任务进行完在把异步任务加入执行栈。

![image](https://user-images.githubusercontent.com/72189350/201929001-14cf8ccf-7bfc-411e-99e5-66b33f7d0e68.png)


## Javascript的事件循环机制

### 前置知识铺垫

在讲事件循环之前，我觉得应该来这里简单铺垫一下浏览器环境。

浏览器有4大进程，其中有一个叫Renderer进程就是用来处理Javascript的，这个进程也是我们经常说的浏览器内核。

在这个进程下面又分为5个线程

- GUI 渲染线程
- Javascript引擎线程  主要在事件循环提供执行栈
- 定时器触发线程
- 事件触发线程  主要在事件循环提供任务队列
- 异步http请求线程

发现没有，这里面5个线程，就有两个是来处理异步任务的😀

首先我们要知道Javascript是单线程编程，也就是Javascript在一个时间只能干一件事。

咦，之前不是说有5个线程吗？怎么现在又叫单线程了(O_o)??

实际上我们所说的多线程指的是能否有多个线程同时运行并发执行，而不是说有多少个线程，Javascript显然是做不到这点的，在这里Javascript的各个线程其实只能处理各自特定的事情。
这还不算GUI和引擎线程之间还是互斥的，因此Javascript是单线程的。

之所以这么设计的原因在于前端是于用户交互的，比如一个DOM元素被两个线程同时操作那就会造成很多麻烦。

### 事件循环

好了，前置知识铺垫完就可以开始进入重头戏了。

那么事件循环是啥呢？

我也不扯什么官方解释了这里直接用大白话解释，事件循环其实就是浏览器处理Javascript代码的过程。

#### 循环机制

既然说是事件循环，那么肯定是有几个提供循环流动的关键结点：

- 主角1：Javascript引擎线程中的执行栈，用来处理Javascript代码执行，每次从循环队列中取出代码执行。
- 主角2: 事件触发线程中的任务队列，取出WebApi中的执行好的代码，放入队列中。
- 主角3：WebApi，取出执行栈中Javascript的异步代码，开其它线程执行，执行完后丢到任务队列。

因此整个过程就是，执行栈按顺序执行代码，如果为同步代码则直接执行，遇到异步代码就丢WebApi中。当同步代码全部执行完后，取出WebApi执行好的异步代码，放进任务队列中。

执行栈在按顺序取出任务队列中的代码执行。
![image](https://user-images.githubusercontent.com/72189350/201939287-342ee9b9-4318-481d-81eb-59e68a9a1eb6.png)

#### 循环过程

在这整个循环过程，有两个如雷贯耳的概念😀，宏任务/微任务。

宏任务：
- script代码
- 定时器
- I/O
- ui交互等

微任务：
- new Promise().then(回调)  注意这里是回调哦
- MutationObserver(html5 新特性)


这两个概念其实是对于事件循环中异步任务的一个分类，我们的每一轮事件循环结束，都相当于进行了一次宏任务+ 微任务。

执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

举个例子：当我们执行完同步代码后，开始执行任务队列中的异步代码，因为异步任务可能不止一个，所以就会分成一轮轮的宏任务，而假如在这个异步任务中，比如说定时器中有个Promise.then()回调的代码，那么这个任务就算是这轮宏任务的微任务，应该加到这个这轮宏任务中执行。

![image](https://user-images.githubusercontent.com/72189350/201943166-3af526cf-4299-487d-975e-3bafe1a6732e.png)

## Promise

### 回调
回调其实是最常见的异步代码了。比如我们封装的各种代码，Ajax请求，文件请求等。在现在这个时代其实已经不推荐使用回调了，因为多重回调会导致回调地狱。
```
// 回调地狱代码实例
setTimeout(function () {
    console.log("First");
    setTimeout(function () {
        console.log("Second");
        setTimeout(function () {
            console.log("Third");
        }, 3000);
    }, 4000);
}, 1000);
```
### Promise介绍 
Promise 是一个构造函数 
- 我们可以创建 Promise 的实例 const p = new Promise() 
- new 出来的 Promise 实例对象，代表一个异步操作

### 手写Promise

### 一些问题

#### 面试例题

## async awiat
